<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>KoreanTama</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    width: 100vw;
    height: 100dvh;
    overflow: hidden;
    background: #fdfdfd;
    font-family: 'DotGothic16', monospace;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }

  #world {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #creature-zone {
    position: relative;
    margin-top: 20vh;
  }

  #bird {
    width: 160px;
    height: 160px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background-image: url('sora/spritesheet.png');
    background-repeat: no-repeat;
    /* 12 cols * 160 = 1920, 6 rows * 160 = 960 */
    background-size: 1920px 960px;
    background-position: 0 0;
    cursor: pointer;
    position: relative;
    z-index: 2;
  }

  /* Thought bubble */
  #thought-bubble {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 8px;
    padding: 10px 14px;
    background: #fff;
    border: 3px solid #5a4e3c;
    border-radius: 16px 16px 16px 4px;
    white-space: nowrap;
    font-size: 16px;
    color: #5a4e3c;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
    box-shadow: 2px 2px 0px #d4c9b8;
  }

  #thought-bubble.visible {
    opacity: 1;
    pointer-events: auto;
  }

  #thought-bubble::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 18px;
    width: 8px;
    height: 8px;
    background: #fff;
    border-right: 3px solid #5a4e3c;
    border-bottom: 3px solid #5a4e3c;
    border-radius: 0 0 4px 0;
    transform: rotate(45deg);
  }

  /* Food options */
  #food-menu {
    position: absolute;
    bottom: 70%;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 10;
  }

  #food-menu.visible {
    opacity: 1;
    pointer-events: auto;
  }

  .food-option {
    background: #fffdf5;
    border: 3px solid #5a4e3c;
    border-radius: 12px;
    padding: 8px 12px;
    font-family: 'DotGothic16', monospace;
    font-size: 14px;
    color: #5a4e3c;
    cursor: pointer;
    transition: transform 0.1s ease, background 0.1s ease;
    box-shadow: 2px 2px 0px #d4c9b8;
    white-space: nowrap;
  }

  .food-option:hover {
    transform: translateY(-2px);
    background: #fff8e0;
  }

  .food-option:active {
    transform: translateY(1px);
    box-shadow: 0 0 0 #d4c9b8;
  }

  /* Pop text */
  .pop-text {
    position: absolute;
    font-family: 'DotGothic16', monospace;
    font-size: 20px;
    color: #e06060;
    pointer-events: none;
    white-space: nowrap;
    z-index: 5;
    animation: popUp 1.4s ease forwards;
  }

  @keyframes popUp {
    0% { opacity: 0; transform: translateX(-50%) translateY(0) scale(0.5); }
    15% { opacity: 1; transform: translateX(-50%) translateY(-10px) scale(1.1); }
    30% { transform: translateX(-50%) translateY(-16px) scale(1); }
    100% { opacity: 0; transform: translateX(-50%) translateY(-50px) scale(0.8); }
  }

  /* Background sparkles */
  .sparkle {
    position: absolute;
    pointer-events: none;
    z-index: 1;
  }

  .sparkle-dot {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #b8a88a;
    border-radius: 1px;
    image-rendering: pixelated;
    animation: sparkleFade 0.5s ease forwards;
  }

  @keyframes sparkleFade {
    0% { opacity: 1; transform: translate(0, 0) scale(1); }
    100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0); }
  }

  /* Status bar */
  #status {
    position: absolute;
    bottom: 16px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 13px;
    color: #b8a88a;
    letter-spacing: 0.5px;
  }

  /* Egg wobble for hatching anticipation */
  @keyframes eggWobble {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-5deg); }
    75% { transform: rotate(5deg); }
  }

  #bird.wobble {
    animation: eggWobble 0.4s ease-in-out;
  }
</style>
</head>
<body>
<div id="world">
  <div id="status"></div>
  <div id="creature-zone">
    <div id="thought-bubble">Î∞∞Í≥†Ìåå...</div>
    <div id="food-menu">
      <button class="food-option" data-food="apple">üçé ÏÇ¨Í≥º</button>
      <button class="food-option" data-food="banana">üçå Î∞îÎÇòÎÇò</button>
      <button class="food-option" data-food="bread">üçû Îπµ</button>
    </div>
    <div id="bird"></div>
  </div>
</div>

<script>
const bird = document.getElementById('bird');
const thoughtBubble = document.getElementById('thought-bubble');
const foodMenu = document.getElementById('food-menu');
const world = document.getElementById('world');
const creatureZone = document.getElementById('creature-zone');
const statusEl = document.getElementById('status');

// Spritesheet: 1536x768, 12 cols x 6 rows, each frame 128x128
// Displayed at 160x160
const DISPLAY = 160;

const ANIMS = {
  eating:   { row: 0, frames: 12, speed: 150 },
  flying:   { row: 1, frames: 6, speed: 150 },
  hatching: { row: 2, frames: 7, speed: 700 },
  idle:     { row: 3, frames: 4, speed: 500 },
  pecking:  { row: 4, frames: 2, speed: 800 },
  walking:  { row: 5, frames: 4, speed: 200 },
};

// --- State ---
let hunger = 100;
const HUNGER_DURATION = 30000;
const HUNGER_TICK = 500;
const HUNGER_PER_TICK = (100 / HUNGER_DURATION) * HUNGER_TICK;

let gameState = 'pre-hatch';
let currentAnim = null;
let currentFrame = 0;
let animTimer = null;
let isPlayingOneShot = false;
let foodMenuOpen = false;
let hatched = false;

let flyTimer = null;
let walkTimer = null;

const FLY_MIN_DELAY = 8000;
const FLY_MAX_DELAY = 20000;
const WALK_MIN_DELAY = 5000;
const WALK_MAX_DELAY = 12000;

// --- Sprite animation ---

function setFrame(anim, frame) {
  const a = ANIMS[anim];
  bird.style.backgroundPosition = `${-frame * DISPLAY}px ${-a.row * DISPLAY}px`;
}

function playLoop(animName) {
  if (animTimer) clearInterval(animTimer);
  currentAnim = animName;
  currentFrame = 0;
  const a = ANIMS[animName];
  setFrame(animName, 0);
  animTimer = setInterval(() => {
    currentFrame = (currentFrame + 1) % a.frames;
    setFrame(animName, currentFrame);
  }, a.speed);
}

function playOnce(animName, callback) {
  if (animTimer) clearInterval(animTimer);
  isPlayingOneShot = true;
  currentAnim = animName;
  currentFrame = 0;
  const a = ANIMS[animName];
  setFrame(animName, 0);
  let frame = 0;
  animTimer = setInterval(() => {
    frame++;
    if (frame >= a.frames) {
      clearInterval(animTimer);
      animTimer = null;
      isPlayingOneShot = false;
      if (callback) callback();
      return;
    }
    setFrame(animName, frame);
  }, a.speed);
}

function playNTimes(animName, n, callback) {
  let count = 0;
  function next() {
    count++;
    if (count >= n) { if (callback) callback(); return; }
    playOnce(animName, next);
  }
  playOnce(animName, next);
}

// --- State machine ---

function enterState(state) {
  gameState = state;

  switch (state) {
    case 'idle':
      playLoop('idle');
      scheduleFly();
      scheduleWalk();
      break;
    case 'hungry':
      playLoop('pecking');
      cancelFly();
      cancelWalk();
      break;
    case 'flying':
      doFly();
      break;
    case 'walking':
      doWalk();
      break;
    case 'eating':
      cancelFly();
      cancelWalk();
      break;
  }
}

function decideDefaultState() {
  if (hunger < 40) {
    enterState('hungry');
  } else {
    enterState('idle');
  }
}

// --- Flying ---

function scheduleFly() {
  cancelFly();
  const delay = FLY_MIN_DELAY + Math.random() * (FLY_MAX_DELAY - FLY_MIN_DELAY);
  flyTimer = setTimeout(() => {
    if (gameState === 'idle' && !isPlayingOneShot && hunger >= 40) {
      enterState('flying');
    }
  }, delay);
}

function cancelFly() {
  if (flyTimer) { clearTimeout(flyTimer); flyTimer = null; }
}

function doFly() {
  cancelWalk();
  playLoop('flying');

  const dx = (Math.random() - 0.5) * 180;
  const dy = -(40 + Math.random() * 60);

  // Flip to face flying direction
  bird.style.transform = dx > 0 ? 'scaleX(-1)' : 'scaleX(1)';

  creatureZone.style.transition = 'transform 1.5s ease-in-out';
  creatureZone.style.transform = `translate(${dx}px, ${dy}px)`;

  setTimeout(() => {
    // Flip to face return direction
    bird.style.transform = dx > 0 ? 'scaleX(1)' : 'scaleX(-1)';
    creatureZone.style.transform = 'translate(0, 0)';
    setTimeout(() => {
      creatureZone.style.transition = '';
      bird.style.transform = 'scaleX(1)';  // Reset to default
      decideDefaultState();
    }, 1500);
  }, 1800);
}

// --- Walking ---

function scheduleWalk() {
  cancelWalk();
  const delay = WALK_MIN_DELAY + Math.random() * (WALK_MAX_DELAY - WALK_MIN_DELAY);
  walkTimer = setTimeout(() => {
    if (gameState === 'idle' && !isPlayingOneShot && hunger >= 40) {
      // Randomly choose between flying and walking
      if (Math.random() < 0.5) {
        enterState('walking');
      } else {
        enterState('flying');
      }
    }
  }, delay);
}

function cancelWalk() {
  if (walkTimer) { clearTimeout(walkTimer); walkTimer = null; }
}

function doWalk() {
  cancelFly();
  playLoop('walking');

  // Walk horizontally (left or right)
  const dx = (Math.random() < 0.5 ? -1 : 1) * (60 + Math.random() * 80);

  // Flip bird to face walking direction (sprite faces left by default)
  bird.style.transform = dx > 0 ? 'scaleX(-1)' : 'scaleX(1)';

  creatureZone.style.transition = 'transform 1.2s linear';
  creatureZone.style.transform = `translate(${dx}px, 0)`;

  setTimeout(() => {
    // Flip to face return direction (opposite of initial)
    bird.style.transform = dx > 0 ? 'scaleX(1)' : 'scaleX(-1)';
    creatureZone.style.transform = 'translate(0, 0)';
    setTimeout(() => {
      creatureZone.style.transition = '';
      bird.style.transform = 'scaleX(1)';  // Reset to default
      decideDefaultState();
    }, 1200);
  }, 1400);
}

// --- Hunger ---

function updateStatus() {
  if (!hatched) return;
  statusEl.textContent = `hunger ${Math.round(hunger)}%`;
}

function updateThought() {
  if (!hatched) return;
  if (hunger < 40 && gameState !== 'eating') {
    thoughtBubble.classList.add('visible');
  } else {
    thoughtBubble.classList.remove('visible');
    closeFoodMenu();
  }
}

setInterval(() => {
  if (!hatched || hunger <= 0) return;
  const wasOk = hunger >= 40;
  hunger = Math.max(0, hunger - HUNGER_PER_TICK);
  updateStatus();
  updateThought();

  if (wasOk && hunger < 40 && gameState === 'idle') {
    enterState('hungry');
  }

}, HUNGER_TICK);

// --- Food ---

function openFoodMenu() {
  foodMenuOpen = true;
  foodMenu.classList.add('visible');
  thoughtBubble.classList.remove('visible');
}

function closeFoodMenu() {
  foodMenuOpen = false;
  foodMenu.classList.remove('visible');
}

function feedBird() {
  closeFoodMenu();
  hunger = 100;
  gameState = 'eating';
  cancelFly();
  cancelWalk();

  playOnce('eating', () => {
    showPop('ÎßõÏûàÏñ¥!');
    updateStatus();
    updateThought();
    decideDefaultState();
  });
}

function showPop(text) {
  const el = document.createElement('div');
  el.className = 'pop-text';
  el.textContent = text;
  el.style.left = '50%';
  el.style.bottom = '100%';
  creatureZone.appendChild(el);
  setTimeout(() => el.remove(), 1400);
}

// --- Interactions ---

// Press (mousedown) -> fly or open food menu
bird.addEventListener('mousedown', (e) => {
  e.preventDefault();
  if (!hatched) return;
  if (isPlayingOneShot || gameState === 'flying' || gameState === 'walking') return;

  if (hunger < 40 || foodMenuOpen) {
    if (foodMenuOpen) closeFoodMenu();
    else openFoodMenu();
  } else {
    // Click triggers flying directly
    enterState('flying');
  }
});

// Prevent click from double-firing after mousedown
bird.addEventListener('click', (e) => {
  e.stopPropagation();
});

document.querySelectorAll('.food-option').forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isPlayingOneShot) return;
    feedBird();
  });
});

// Background sparkles
world.addEventListener('click', (e) => {
  if (e.target.closest('#creature-zone')) return;
  createSparkle(e.clientX, e.clientY);
});

function createSparkle(x, y) {
  const c = document.createElement('div');
  c.className = 'sparkle';
  c.style.left = x + 'px';
  c.style.top = y + 'px';
  const n = 5 + Math.floor(Math.random() * 3);
  for (let i = 0; i < n; i++) {
    const dot = document.createElement('div');
    dot.className = 'sparkle-dot';
    const angle = (Math.PI * 2 * i) / n + (Math.random() - 0.5) * 0.5;
    const dist = 12 + Math.random() * 18;
    dot.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
    dot.style.setProperty('--dy', Math.sin(angle) * dist + 'px');
    dot.style.animationDelay = (Math.random() * 0.1) + 's';
    const colors = ['#b8a88a', '#c9b99a', '#a8987a', '#d4c4a4'];
    dot.style.background = colors[Math.floor(Math.random() * colors.length)];
    c.appendChild(dot);
  }
  world.appendChild(c);
  setTimeout(() => c.remove(), 600);
}

// --- Hatching sequence ---

function startHatching() {
  gameState = 'pre-hatch';
  statusEl.textContent = '...?';

  // Show egg (first hatching frame)
  setFrame('hatching', 0);

  // Wobble the egg a few times, then hatch
  let wobbles = 0;
  const maxWobbles = 3;

  function wobble() {
    bird.classList.add('wobble');
    bird.addEventListener('animationend', function handler() {
      bird.removeEventListener('animationend', handler);
      bird.classList.remove('wobble');
      wobbles++;
      if (wobbles < maxWobbles) {
        setTimeout(wobble, 800 + Math.random() * 400);
      } else {
        setTimeout(hatch, 500);
      }
    });
  }

  setTimeout(wobble, 1000);

  function hatch() {
    gameState = 'hatching';
    playOnce('hatching', () => {
      hatched = true;
      showPop('ÏïàÎÖï!');
      updateStatus();
      decideDefaultState();
    });
  }
}

// --- Init ---
startHatching();
</script>
</body>
</html>
